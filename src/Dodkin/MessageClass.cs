using System.Net;

namespace Dodkin
{
    public readonly record struct MessageClass(ushort Value)
    {
        //  Normal message
        public static readonly MessageClass Normal = FromCode(0, 0, 0x00);

        //  Report message
        public static readonly MessageClass Report = FromCode(0, 0, 0x01);

        //  Arrival acknowledgment. The message has reached its destination queue
        public static readonly MessageClass AckReachQueue = FromCode(0, 0, 0x02);

        //  Receive acknowledgment. The message has been received by an application
        public static readonly MessageClass AckReceive = FromCode(0, 1, 0x00);

        //-----------------------------------------------
        //  Negative arrival acknowledgments

        //  Destination queue cannot be reached, the queue may have been deleted
        public static readonly MessageClass NackBadDestinationQueue = FromCode(1, 0, 0x00);

        //  The message was purged before reaching its destination queue
        public static readonly MessageClass NackMessagePurged = FromCode(1, 0, 0x01);

        //  Time to reach queue has expired
        public static readonly MessageClass NackReachQueueTimeout = FromCode(1, 0, 0x02);

        //  The message has exceeded the queue quota
        public static readonly MessageClass NackQueueExceedQuota = FromCode(1, 0, 0x03);

        //  The sender does not have send access rights to the queue.
        public static readonly MessageClass NackAccessDenied = FromCode(1, 0, 0x04);

        //  The message hop count was exceeded
        public static readonly MessageClass NackHopCountExceeded = FromCode(1, 0, 0x05);

        //  The message signature is bad. The message could not be authenticated.
        public static readonly MessageClass NackBadSignature = FromCode(1, 0, 0x06);

        //  The message could not be decrypted.
        public static readonly MessageClass NackBadEncryption = FromCode(1, 0, 0x07);

        //  The message could not be encrypted for the destination.
        public static readonly MessageClass NackCouldNotEncrypt = FromCode(1, 0, 0x08);

        //  The message was sent to a non-transactional queue within a transaction.
        public static readonly MessageClass NackNotTransactionalQueue = FromCode(1, 0, 0x09);

        //  The message was sent to a transactional queue not within a transaction.
        public static readonly MessageClass NackNotTransactionalMessage = FromCode(1, 0, 0x0A);

        //  The requested crypto provider for encryption is not supported by the destination.
        public static readonly MessageClass NackUnsupportedCryptoProvider = FromCode(1, 0, 0x0B);

        // The QM GUID has changed and therefore the messages was thrown away.
        public static readonly MessageClass NackSourceComputerGuidChanged = FromCode(1, 0, 0x0C);

        // The message was sent by downlevel machines (earlier than msmq4) and the message size
        // with the subqueue and IPV6 headers exceeded the max message size
        public static readonly MessageClass NackMessageTooLarge = FromCode(1, 0, 0x0D);

        //-----------------------------------------------
        //  Negative receive acknowledgments

        //  The queue was deleted, after the message arrived
        public static readonly MessageClass NackQueueDeleted = FromCode(1, 1, 0x00);

        //  The message was purged at the destination queue
        public static readonly MessageClass NackQueuePurged = FromCode(1, 1, 0x01);

        //  Time to receive has expired while the message was still in its destination queue
        //  (generated by destination)
        public static readonly MessageClass NackReceiveTimeout = FromCode(1, 1, 0x02);

        //  Time to receive has expired while the message was still in its local outgoing queue
        //  (generated locally by sender)
        public static readonly MessageClass NackReceiveTimeoutAtSender = FromCode(1, 1, 0x03);

        // Message was rejected by a receiving application (by calling MQMarkRejected API)
        public static readonly MessageClass NackReceiveRejected = FromCode(1, 1, 0x04);

        public HttpStatusCode HttpStatusCode =>
            (this.Value & 0xA000) == 0xA000 ? (HttpStatusCode)(this.Value & 0x1FF) :
            this.Value == AckReachQueue.Value ? HttpStatusCode.Accepted :
            (this.Value & 0x8000) > 0 ? HttpStatusCode.Conflict :
            HttpStatusCode.OK;

        //  Message class values are 16 bits laid out as follows:
        //
        //   1 1 1 1 1 1
        //   5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
        //  +-+-+-+-------+-----------------+
        //  |S|R|H| Rsrve |    Class code   |
        //  +-+-+-+-------+-----------------+
        //
        //  where
        //
        //  Class code must be 9 bits, to accomodate http too. (40X, 50X codes).
        //
        //      S - is the severity flag
        //          0 - Normal Message/Positive Acknowledgment (ACK)
        //          1 - Negative Acknowledgment (NACK)
        //
        //      R - is the receive flag
        //          0 - Arrival ACK/NACK
        //          1 - Receive ACK/NACK
        //
        //      H - is http flag
        //          0 - no http
        //          1 - http
        //
        //      Top 4 bits of Class code are reserved for user-specified acks
        public static MessageClass FromCode(ushort severity, ushort receive, ushort code)
        {
            return new((ushort)((severity << 15) | (receive << 14) | code));
        }
    }
}